#!/usr/bin/env raku

use XML;

# A map of snippet paths to their contents in AsciiDoc.
my %snippets;

# A separate hash of known snippet names already defined somewhere else.
my %defined-snippets;

# Return the name of the snippet to use for the given path.
sub snippet-name-for-path(Str $path --> Str) {
    my $name = $path;
    $name ~~ s/^ [ .* '/' ]? ( <-[/.]>+ ) '.flsnp' $/$0/;
    if ! $/ {
        note "$*CURRENT-FILE: unexpected <MadCap:snippetText> source ($path)."
    }

    $name
}

# Add a snippet with the specified path, i.e. read it from the file and
# convert its contents to AsciiDoc if it hadn't been done yet.
#
# Returns the name to use for this snippet.
sub snippet-add-or-get(Str $path --> Str) {
    my $name = snippet-name-for-path($path);

    if %defined-snippets{$name}:!exists and %snippets{$path}:!exists {
        %snippets{$path} = convert-html-to-adoc($path)
    }

    $name
}

# Return all snippet definitions to put at the beginning of an AsciiDoc
# document.
sub snippet-definitions(--> Str) {
    # Note that we need to use pass:quotes to expand AsciiDoc markup inside
    # the snippets.
    my $adoc = '';
    for %snippets.kv -> $path, $text {
        $adoc ~= ":{ snippet-name-for-path($path) }: pass:quotes[{ $text.trim }]\n"
    }

    $adoc
}

sub convert-html-to-adoc(Str $path --> Str) {
    my $html-doc = from-xml-file($path);
    my $html-body = $html-doc.root.elements(:TAG<body>, :SINGLE);

    convert-children-to-adoc($html-body)
}

# Iterate over all children of an element calling the appropriate conversion
# functions for each of them.
sub convert-children-to-adoc(XML::Element $elem, Bool :$skip-ws --> Str) {
    my $adoc = '';
    if $elem.nodes {
        for $elem.nodes -> $child {
            if $child ~~ XML::Element {
                my $convert-child = "convert-{ $child.name }-to-adoc";
                $convert-child ~~ tr/:/-/;
                $adoc ~= &::($convert-child)($child);
                CATCH {
                    when X::NoSuchSymbol {
                        note "$*CURRENT-FILE: unsupported tag { $child.name }."
                    }
                }
            } elsif $child ~~ XML::Text {
                # Unindent the text, this is important because many AsciiDoc
                # constructs must be at the beginning of the line, without any
                # spaces.
                my $text = ~$child;
                $text ~~ s:g/\n\h+/\n/;

                # Also handle the only entity which seems to be used in Flare
                # HTML.
                $text ~~ s:g/'&#160;'/\{nbsp}/;

                if $skip-ws && $text eq "\n" {
                    # Skip text consisting of whitespace only.
                    next
                }

                $adoc ~= $text
            } else {
                note qq{Ignoring unknown XML node "$child".}
            }
        }
    }

    return $adoc
}

# Helper converting the given element to AsciiDoc by using the given prefix
# and suffix around the conversion of its contents.
sub convert-element-to-adoc(Str $prefix, XML::Element $elem, Str $suffix = '' --> Str) {
    $prefix ~ convert-children-to-adoc($elem) ~ $suffix
}

# Another helper creating a header of the given level.
sub make-adoc-header(Int $level, XML::Element $elem --> Str) {
    # All header contents must be on the same line (we could also use '+' for
    # continuation, but this doesn't look good).
    my $header-text = convert-children-to-adoc($elem);
    $header-text ~~ s:g/\n/ /;

    # The number of equal signs is level+1, in particular we never create
    # level 0 headers here, as this corresponds to the document title and can
    # only be used once.
    "\n" ~ ('=' x ($level + 1)) ~ ' ' ~ $header-text ~ "\n"
}

sub convert-h1-to-adoc(XML::Element $elem --> Str) {
    make-adoc-header(1, $elem)
}

sub convert-h2-to-adoc(XML::Element $elem --> Str) {
    make-adoc-header(2, $elem)
}

sub convert-h3-to-adoc(XML::Element $elem --> Str) {
    make-adoc-header(3, $elem)
}

sub convert-h4-to-adoc(XML::Element $elem --> Str) {
    make-adoc-header(4, $elem)
}

sub convert-h5-to-adoc(XML::Element $elem --> Str) {
    make-adoc-header(5, $elem)
}

sub convert-h6-to-adoc(XML::Element $elem --> Str) {
    # There is no level 6 title in AsciiDoc, so handle this one in the same
    # way as <h5>.
    make-adoc-header(5, $elem)
}

sub convert-p-to-adoc(XML::Element $elem --> Str) {
    # TODO: Handle style="font-weight: bold".
    # TODO: Handle class="note".
    convert-children-to-adoc($elem)
}

sub convert-br-to-adoc(XML::Element $elem --> Str) {
    # This shouldn't happen.
    if $elem.nodes {
        note "$*CURRENT-FILE: non-empty <br> contents ignored."
    }

    "\n"
}

sub convert-to-adoc-inline-delim(Str $delim, XML::Element $elem --> Str) {
    my $contents = convert-children-to-adoc($elem);

    # Blank lines are not allowed inside inline styles.
    $contents ~~ s:g/\n\n/\n/;

    $delim ~ $contents ~ $delim
}

sub convert-to-adoc-inline-style(Str $style, XML::Element $elem --> Str) {
    "[.$style]" ~ convert-to-adoc-inline-delim('#', $elem)
}

sub convert-span-to-adoc(XML::Element $elem --> Str) {
    my $class = $elem.attribs<class>;

    # Not using any style would result in the inline style being highlighted,
    # which is probably not what we want, so just don't do anything special
    # for it in this case.
    $class ?? convert-to-adoc-inline-style($class, $elem)
           !! convert-children-to-adoc($elem)

}

sub convert-ol-to-adoc(XML::Element $elem --> Str) {
    # Dynamically scoped variable used in convert-li-to-adoc().
    my $*LIST-LEADER = '.';
    convert-children-to-adoc($elem)
}

sub convert-ul-to-adoc(XML::Element $elem --> Str) {
    my $*LIST-LEADER = '*';
    convert-children-to-adoc($elem)
}

sub convert-li-to-adoc(XML::Element $elem --> Str) {
    my $adoc = $*LIST-LEADER ~ ' ';

    my $list-text = convert-children-to-adoc($elem);

    # List item must start at the same line as the list leader, so remove all
    # leading whitespace that could be present in HTML.
    $list-text .= trim-leading;

    # We also can't have blank lines in the item text, so if we do, use an
    # open block to ensure the list continues across them, as recommended in
    # the documentation. We could also use '+', but this seems simpler and
    # more robust.
    if $list-text.contains("\n\n") {
        my ($leading, $rest) = $list-text.split("\n\n", 2);

        $adoc ~= qq:to/END/;
            $leading
            +
            --
            $rest
            --
            END
    } else {
        $adoc ~= $list-text
    }

    $adoc
}

sub convert-dl-to-adoc(XML::Element $elem --> Str) {
    # Nothing special to do for the start of a definition list, just ensure
    # that it starts and ends with a new line.
    "\n" ~ convert-children-to-adoc($elem) ~ "\n"
}

sub convert-dt-to-adoc(XML::Element $elem --> Str) {
    convert-children-to-adoc($elem) ~ "::"
}

sub convert-dd-to-adoc(XML::Element $elem --> Str) {
    '  ' ~ convert-children-to-adoc($elem)
}

sub convert-img-to-adoc(XML::Element $elem --> Str) {
    my $adoc = '';

    my $title = ''; # Optional image title.
    for $elem.attribs.kv -> $attr, $value {
        given $attr {
            when 'src' {
                # We assume that all images are in the same directory and
                # remove it from them.
                my $parts = $value.IO.parts;
                if $*IMAGE-DIRECTORY {
                    # Compare the directories case-insensitively to account
                    # for HTML files created on case-insensitive file systems.
                    # In the actual use it doesn't matter as we only use the
                    # base name in the generated AsciiDoc.
                    note "$*CURRENT-FILE: image $value not in $*IMAGE-DIRECTORY."
                        if $parts.dirname.fc ne $*IMAGE-DIRECTORY.fc
                } else {
                    # Remember it for the next time.
                    $*IMAGE-DIRECTORY = $parts.dirname
                }

                # Our images are all block images and never inline.
                $adoc = "\nimage::{ $parts.basename }"
            }

            when 'style' {
                # Ignore it.
            }

            when 'alt' {
                $title = $value
            }

            default {
                note "$*CURRENT-FILE: $attr attribute of <img> ignored."
            }
        }
    }

    if $adoc {
        $adoc ~= "[$title]\n"
    } else {
        note "$*CURRENT-FILE: <img> without src attribute?"
    }

    $adoc
}

sub convert-a-to-adoc(XML::Element $elem --> Str) {
    # Distinguish between external links and anchors that can be used as
    # targets of <MadCap:xref>.
    my $adoc;
    if defined my $href = $elem.attribs<href> {
        $adoc = "link:{ $href }[{ $elem.attribs<title> // ''}]"
    } else {
        my ($name, $id) = $elem.attribs<name id>;
        if ! defined $id {
            note "$*CURRENT-FILE: unrecognized <a> format."
        }
        if $id ne $name {
            note "$*CURRENT-FILE: mismatch between <a> name ($name) and id ($id)."
        }

        $adoc = "[[$id]]"
    }

    $adoc
}

sub convert-b-to-adoc(XML::Element $elem --> Str) {
    convert-to-adoc-inline-delim('*', $elem)
}

sub convert-strong-to-adoc(XML::Element $elem --> Str) {
    convert-to-adoc-inline-delim('*', $elem)
}

sub convert-em-to-adoc(XML::Element $elem --> Str) {
    convert-to-adoc-inline-delim('_', $elem)
}

sub convert-q-to-adoc(XML::Element $elem --> Str) {
    convert-to-adoc-inline-delim('`', $elem)
}

sub convert-code-to-adoc(XML::Element $elem --> Str) {
    convert-to-adoc-inline-style('code', $elem)
}

sub convert-blockquote-to-adoc(XML::Element $elem --> Str) {
    qq:to/END/;
        ____
        { convert-children-to-adoc($elem) }
        ____
        END
}

sub convert-col-to-adoc(XML::Element $elem --> Str) {
    # TODO: Parse width and use it for the cols attribute of the table.
    ''
}

sub convert-td-to-adoc(XML::Element $elem --> Str) {
    my $cell-text = convert-children-to-adoc($elem);

    # The cell contents must be on the same line as '|' and while line breaks
    # are allowed in it, we shouldn't have any trailing ones.
    '|' ~ $cell-text.trim
}

sub convert-tr-to-adoc(XML::Element $elem --> Str) {
    # Ignore any whitespace inside this tag, its only contents should be
    # inside the nested <td>s.
    convert-children-to-adoc($elem, :skip-ws)
}

sub convert-tbody-to-adoc(XML::Element $elem --> Str) {
    convert-children-to-adoc($elem)
}

sub convert-table-to-adoc(XML::Element $elem --> Str) {
    my $table-marker = "|===\n";

    "\n" ~ convert-element-to-adoc($table-marker, $elem, $table-marker)
}

sub convert-MadCap-xref-to-adoc(XML::Element $elem --> Str) {
    my $href = $elem.attribs<href>;
    if ! defined $href {
        note "$*CURRENT-FILE: no href in MadCap:xref tag?"
    }

    # Adjust the links to the other documents.
    $href ~~ s/'.htm' <?before $ | '#'>/.adoc/;

    my $title = convert-children-to-adoc($elem);

    # This seems to get replaced by the actual page number, but we can't do it
    # in AsciiDoc, so just drop this part.
    $title ~~ s/' on page{nbsp}1'//;

    # Not sure what the precise syntax is here, but the text in quotes should
    # be used as the link title and MadCap Flare automatically uses "see ..."
    # if it's empty, so do something similar.
    $title ~~ s/^\"//;
    $title ~~ s/\"$//;

    if $title eq '' {
        my $anchor ~= S/.* '#'// with $href;
        $title = "see $anchor";
    }

    "xref:{ $href }[$title]";
}

sub convert-MadCap-snippetText-to-adoc(XML::Element $elem --> Str) {
    if $elem.nodes {
        note "$*CURRENT-FILE: non-empty <MadCap:snippetText> contents ignored."
    }

    '{' ~ snippet-add-or-get($elem.attribs<src>) ~ '}'
}

sub convert-MadCap-tocProxy-to-adoc(XML::Element $elem --> Str) {
    # Nothing to do here, TOC is generated automatically.
    ''
}

sub MAIN(
        *@flare-files,
        Bool :$verbose,          #= Be more talkative.
        Str  :$defined-snippets, #= Already defined and known snippets.
    ) {
    # Prepopulate known snippets with the snippets that are already defined
    # somewhere. As we don't have their expansions, just use "Any".
    if $defined-snippets {
        my @defined-snippets = $defined-snippets.split(',');
        %defined-snippets{@defined-snippets} = (Any) xx @defined-snippets;
    }

    # Dynamically scoped variable containing the images directory.
    my $*IMAGE-DIRECTORY = '';

    my $exit-code = 0;
    for @flare-files -> $flare-file {
        # Dynamically scoped variable used in the error messages.
        my $*CURRENT-FILE = $flare-file.IO.basename;

        my $out-file = $flare-file.IO.subst(/'.' html? $/) ~ '.adoc';
        # say qq{Converting "$flare-file" to "$out-file"...} if $verbose;

        my $adoc = indir $flare-file.IO.dirname, { convert-html-to-adoc($*CURRENT-FILE) };

        # Remove insignificant leading and trailing spaces and blank lines,
        # but leave a new line at the end of file.
        $adoc ~~ s/^\s+//;
        $adoc ~~ s:g/\n\n\n+/\n\n/;
        $adoc ~~ s/\s+$/\n/;

        $out-file.IO.spurt($adoc);

        CATCH {
            default {
                note qq{Error converting "$flare-file": $_.};
                $exit-code = 1;

                next
            }
        }
    }

    if %snippets {
        say "The following snippet definitions are required:";
        say snippet-definitions();
    }

    if $exit-code == 0 {
        say "Done in { now - INIT now }s"
    }

    exit $exit-code
}
