#!/usr/bin/env raku

use XML;

# Iterate over all children of an element calling the appropriate conversion
# functions for each of them.
sub convert-children-to-adoc(XML::Element $elem --> Str) {
    my $adoc = '';
    if $elem.nodes {
        for $elem.nodes -> $child {
            if $child ~~ XML::Element {
                my $convert-child = "convert-{ $child.name }-to-adoc";
                $convert-child ~~ tr/:/-/;
                $adoc ~= &::($convert-child)($child);
                CATCH {
                    when X::NoSuchSymbol {
                        note "$*CURRENT-FILE: unsupported tag { $child.name }."
                    }
                }
            } elsif $child ~~ XML::Text {
                # Unindent the text, this is important because many AsciiDoc
                # constructs must be at the beginning of the line, without any
                # spaces.
                my $text = ~$child;
                $text ~~ s:g/\n\h+/\n/;

                # Also handle the only entity which seems to be used in Flare
                # HTML.
                $text ~~ s:g/'&#160;'/\{nbsp}/;

                $adoc ~= $text
            } else {
                note qq{Ignoring unknown XML node "$child".}
            }
        }
    }

    return $adoc
}

# Helper converting the given element to AsciiDoc by using the given prefix
# and suffix around the conversion of its contents.
sub convert-element-to-adoc(Str $prefix, XML::Element $elem, Str $suffix = '' --> Str) {
    $prefix ~ convert-children-to-adoc($elem) ~ $suffix
}

# Another helper creating a header of the given length.
sub make-adoc-header(Int $level, XML::Element $elem --> Str) {
    # All header contents must be on the same line (we could also use '+' for
    # continuation, but this doesn't look good).
    my $header-text = convert-children-to-adoc($elem);
    $header-text ~~ s:g/\n/ /;

    ('=' x $level) ~ ' ' ~ $header-text ~ "\n"
}

sub convert-h1-to-adoc(XML::Element $elem --> Str) {
    make-adoc-header(1, $elem)
}

sub convert-h2-to-adoc(XML::Element $elem --> Str) {
    make-adoc-header(2, $elem)
}

sub convert-h3-to-adoc(XML::Element $elem --> Str) {
    make-adoc-header(3, $elem)
}

sub convert-h4-to-adoc(XML::Element $elem --> Str) {
    make-adoc-header(4, $elem)
}

sub convert-h5-to-adoc(XML::Element $elem --> Str) {
    make-adoc-header(5, $elem)
}

sub convert-h6-to-adoc(XML::Element $elem --> Str) {
    make-adoc-header(6, $elem)
}

sub convert-p-to-adoc(XML::Element $elem --> Str) {
    # TODO: Handle style="font-weight: bold".
    convert-children-to-adoc($elem)
}

sub convert-br-to-adoc(XML::Element $elem --> Str) {
    # This shouldn't happen.
    if $elem.nodes {
        note "$*CURRENT-FILE: non-empty <br> contents ignored."
    }

    "\n"
}

sub convert-span-to-adoc(XML::Element $elem --> Str) {
    my $adoc = '';

    my $class = $elem.attribs<class>;
    $adoc ~= "[.$class]" if defined $class;

    $adoc ~ convert-element-to-adoc('#', $elem, '#')
}

sub convert-ol-to-adoc(XML::Element $elem --> Str) {
    # Dynamically scoped variable used in convert-li-to-adoc().
    my $*LIST-LEADER = '.';
    convert-children-to-adoc($elem)
}

sub convert-ul-to-adoc(XML::Element $elem --> Str) {
    my $*LIST-LEADER = '*';
    convert-children-to-adoc($elem)
}

sub convert-li-to-adoc(XML::Element $elem --> Str) {
    my $list-text = convert-children-to-adoc($elem);

    # List item must start at the same line as the list leader, so remove all
    # leading whitespace that could be present in HTML.
    $list-text ~~ s/^\s+//;

    $*LIST-LEADER ~ ' ' ~ $list-text
}

sub convert-img-to-adoc(XML::Element $elem --> Str) {
    my $adoc = '';

    for $elem.attribs.kv -> $attr, $value {
        given $attr {
            when 'src' {
                # We assume that all images are in the same directory and
                # remove it from them.
                my $parts = $value.IO.parts;
                if $*IMAGE-DIRECTORY {
                    note "$*CURRENT-FILE: image not in $*IMAGE-DIRECTORY."
                        if $parts.dirname ne $*IMAGE-DIRECTORY
                } else {
                    # Remember it for the next time.
                    $*IMAGE-DIRECTORY = $parts.dirname
                }

                # Our images are all block images and never inline.
                $adoc = "\nimage::{ $parts.basename }"
            }

            when 'style' {
                # Ignore it.
            }

            default {
                note "$*CURRENT-FILE: $attr attribute of <img> ignored."
            }
        }
    }

    if $adoc {
        $adoc ~= "[]\n"
    } else {
        note "$*CURRENT-FILE: <img> without src attribute?"
    }

    $adoc
}

sub convert-em-to-adoc(XML::Element $elem --> Str) {
    convert-element-to-adoc('_', $elem, '_')
}

sub convert-MadCap-xref-to-adoc(XML::Element $elem --> Str) {
    # TODO: Handle this as a link?
    convert-children-to-adoc($elem)
}

sub MAIN(
        *@flare-files,
        Bool :$verbose, #= Be more talkative.
    ) {
    # Dynamically scoped variable containing the images directory.
    my $*IMAGE-DIRECTORY = '';

    my $exit-code = 0;
    for @flare-files -> $flare-file {
        # Dynamically scoped variable used in the error messages.
        my $*CURRENT-FILE = $flare-file.IO.basename;

        my $out-file = $flare-file.IO.subst(/'.' html? $/) ~ '.adoc';
        # say qq{Converting "$flare-file" to "$out-file"...} if $verbose;

        my $html-doc = from-xml-file($flare-file);
        my $html-body = $html-doc.root.elements(:TAG<body>, :SINGLE);
        my $adoc = convert-children-to-adoc($html-body);

        # Remove insignificant leading and trailing spaces and blank lines,
        # but leave a new line at the end of file.
        $adoc ~~ s/^\s+//;
        $adoc ~~ s:g/\n\n\n+/\n\n/;
        $adoc ~~ s/\s+$/\n/;

        $out-file.IO.spurt($adoc);

        CATCH {
            default {
                note qq{Error converting "$flare-file": $_.};
                $exit-code = 1;

                next
            }
        }
    }

    if $exit-code == 0 {
        say "Done in { now - INIT now }s"
    }

    exit $exit-code
}
